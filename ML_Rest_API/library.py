# -*- coding: utf-8 -*-
"""Karan “Batman” Mohindroo - 1. Chapter 2 Assessment Notebook [Student].ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V5zTfpkx24Mnlxrqjm28bTkBRFb4Ctn2

## **Assessment on Reading Assignment**

---

> **Objective: To test your understanding of the concepts discussed in the read assignment using a series of coding challenges.**

### **Challenge 1: Simulated ATM**

#### **Objective:**
Create a program that simulates an ATM system. The user can perform actions like checking their balance, depositing money, and withdrawing money. The program runs in a loop until the user chooses to exit.

#### **Requirements:**
1. Start with a fixed account balance, e.g., `$500`.
2. The program should present the user with the following options:
   - **1. Check Balance**: Display the current account balance.
   - **2. Deposit**: Prompt the user to enter an amount to deposit, then add it to the balance.
   - **3. Withdraw**: Prompt the user to enter an amount to withdraw. If the amount exceeds the current balance, display an error message.
   - **4. Exit**: Exit the program and print a goodbye message.
3. The program should run in a loop, displaying the menu after every action until the user selects the "Exit" option.

#### **Implementation Notes:**
- Validate inputs to ensure they are numeric where appropriate.

#### **Example Input/Output:**

```plaintext
Welcome to the ATM!
Your current balance is $500.

Select an option:
  1. Check Balance
  2. Deposit
  3. Withdraw
  4. Exit
Enter your choice: 1
Your current balance is $500.

Select an option:
  1. Check Balance
  2. Deposit
  3. Withdraw
  4. Exit
Enter your choice: 2
Enter deposit amount: 200
You have successfully deposited $200. Your new balance is $700.

Select an option:
  1. Check Balance
  2. Deposit
  3. Withdraw
  4. Exit
Enter your choice: 3
Enter withdrawal amount: 800
Error: Insufficient funds. Your balance is $700.

Select an option:
  1. Check Balance
  2. Deposit
  3. Withdraw
  4. Exit
Enter your choice: 4
Thank you for using the ATM. Goodbye!
```
"""

def atm_simulator():
  balance = 500

  while True:
    print("\nWelcome to the ATM!")
    print("Your current balance is $", balance)
    print("\nSelect an option:")
    print("  1. Check Balance")
    print("  2. Deposit")
    print("  3. Withdraw")
    print("  4. Exit")

    choice = input("Enter your choice: ")

    if choice == '1':
      print("Your current balance is $", balance)
    elif choice == '2':
      deposit_amount = float(input("Enter deposit amount: "))
      balance += deposit_amount
      print("You have successfully deposited $", deposit_amount, ". Your new balance is $", balance)
    elif choice == '3':
      withdrawal_amount = float(input("Enter withdrawal amount: "))
      if withdrawal_amount > balance:
        print("Error: Insufficient funds. Your balance is $", balance)
      else:
        balance -= withdrawal_amount
        print("You have successfully withdrawn $", withdrawal_amount, ". Your new balance is $", balance)
    elif choice == '4':
      print("Thank you for using the ATM. Goodbye!")
      break
    else:
      print("Invalid choice. Please see an ophthalmologist.")


# Call the ATM simulator
# atm_simulator()

"""

### **Challenge 2: Unique Character Generator**

#### **Objective**:
Write a **generator function** that processes a string and yields **unique characters**, ignoring case. The program should:
1. Ignore repeated characters, even if they appear in different cases (e.g., `'P'` and `'p'` should be treated as the same).
2. Preserve the **order of first appearance** of unique characters.
3. Skip any spaces or non-alphabetic characters.

#### **Requirements**:
- Create a generator function called `unique_characters()`.
- Use the generator to process the string `"Python Programming"`.
- Print each unique character on a new line.
- Handle edge cases like empty strings, special characters, or numeric values.

#### **Example Input/Output**:

##### **Example 1**:
Input: `"Python Programming"`

Output:
```plaintext
P
y
t
h
o
n
r
g
a
m
i
```

##### **Example 2**:
Input: `"Hello, World!"`

Output:
```plaintext
H
e
l
o
W
r
d
```

##### **Example 3**:
Input: `"12345!!Python12345!!"`

Output:
```plaintext
P
y
t
h
o
n
```

#### **Implementation Details**:
1. **Case Insensitivity**:
   - Convert characters to lowercase or uppercase before checking for uniqueness.
2. **Skip Non-Alphabetic Characters**:
3. **Preserve Order**:
   - track already-yielded characters while maintaining the input string's order.
4. **Edge Cases**:
   - Handle empty strings (no output).
   - Handle strings with only special characters or digits (no output).


"""

def unique_characters(input_string):
  tracker = set()
  for char in input_string:
    charlow = char.lower()
    if charlow.isalpha() and charlow not in tracker:
      tracker.add(char)
      yield char

# Test the generator with a sample string
test_string = "Python Programming"
print("Unique characters:")
for char in unique_characters(test_string):
    print(char)

"""

### **Challenge 3: Employee Management System (Using Inheritance)**

#### **Objective**:
Create a program to manage employees in a company. There should be two types of employees:
1. **Regular Employee**:
   - Has attributes like `name`, `age`, and `salary`.
   - Can calculate their annual salary.
2. **Manager (Inherits from Employee)**:
   - Inherits all attributes from `Employee` and has an additional attribute `bonus`.
   - Overrides the method to calculate annual salary to include the bonus.

#### **Requirements**:
1. Create a base class `Employee` with attributes `name`, `age`, and `salary`.
   - Add a method `get_annual_salary()` that calculates the annual salary.
2. Create a derived class `Manager` that inherits from `Employee`.
   - Add an additional attribute `bonus`.
   - Override the `get_annual_salary()` method to include the bonus.
3. Test the classes by creating both regular employees and managers, and calculate their annual salaries.

---

#### **Example Input/Output**:

##### **Example 1**:
```python
# Create regular employees
emp1 = Employee("Alice", 25, 50000)
emp2 = Employee("Bob", 30, 60000)

# Create managers
mgr1 = Manager("Charlie", 40, 80000, 10000)

# Calculate annual salaries
print(emp1.get_annual_salary())  # Output: 50000
print(emp2.get_annual_salary())  # Output: 60000
print(mgr1.get_annual_salary())  # Output: 90000 (80000 + 10000)
```
"""

## Your code here
class Employee:
  def __init__(self, name, age, salary):
    self.name = name
    self.age = age
    self.salary = salary

  def get_annual_salary(self):
    return self.salary

class Manager(Employee):
  def __init__(self, name, age, salary, bonus):
    super().__init__(name, age, salary)
    self.bonus = bonus

  def get_annual_salary(self):
    return super().get_annual_salary() + self.bonus

# Test cases
emp1 = Employee("Alice", 25, 50000)
emp2 = Employee("Bob", 30, 60000)
mgr1 = Manager("Charlie", 40, 80000, 10000)

print(emp1.get_annual_salary())  # Output: 50000
print(emp2.get_annual_salary())  # Output: 60000
print(mgr1.get_annual_salary())  # Output: 90000 (80000 + 10000)

"""### **Challenge 4: Inventory Management System (Using Classes and Magic Methods)**

#### **Objective**:
Create a simple inventory management system for a store. Each item in the inventory should:
1. Have attributes like `name`, `price`, and `quantity`.
2. Support operations like:
   - Adding two items of the same type (combine their quantities).
   - Comparing two items to check if they are equal (same name and price).
   - Displaying the item details using a string representation (using `__str__`).

#### **Requirements**:
1. Implement a class called `Item` with attributes `name`, `price`, and `quantity`.
2. Add the following magic methods:
   - `__add__`: Allows adding two items of the same type to combine their quantities.
   - `__eq__`: Compares two items for equality (based on `name` and `price`).
   - `__str__`: Returns a string representation of the item in the format: `"Item(name=Apple, price=1.5, quantity=10)"`.
3. Test the class by creating a few items and performing the operations.

---

#### **Example Input/Output**:

##### **Example 1**:
```python
item1 = Item("Apple", 1.5, 10)
item2 = Item("Apple", 1.5, 5)
item3 = Item("Banana", 0.5, 20)

# Adding items
combined_item = item1 + item2
print(combined_item)  # Output: Item(name=Apple, price=1.5, quantity=15)

# Comparing items
print(item1 == item2)  # Output: True
print(item1 == item3)  # Output: False

# String representation
print(item1)  # Output: Item(name=Apple, price=1.5, quantity=10)
```


"""

class Item:
  def __init__(self, name, price, quantity):
    self.name = name
    self.price = price
    self.quantity = quantity

  def __add__(self, other):
    if self.name == other.name and self.price == other.price:
      return Item(self.name, self.price, self.quantity + other.quantity)

  def __eq__(self, other):
    return self.name == other.name and self.price == other.price

  def __str__(self):
    return f"Item(name={self.name}, price={self.price}, quantity={self.quantity})"

# Test cases
item1 = Item("Apple", 1.5, 10)
item2 = Item("Apple", 1.5, 5)
item3 = Item("Banana", 0.5, 20)

combined_item = item1 + item2
print(combined_item)
print(item1 == item2)
print(item1 == item3)

"""### **Challenge 5: Smart Device Management System (Using Multiple Inheritance)**

#### **Objective**:
Design a system to manage **Smart Devices** that are either **Power-Operated** or **WiFi-Enabled**, or both. Use **multiple inheritance** to combine features from different base classes. Implement a `SmartDevice` class that inherits attributes and behaviors from the relevant parent classes.


#### **Requirements**:
1. Create the following classes:
   - `PowerDevice`: Represents devices that require power to operate.
     - Attribute: `power_status` (e.g., "On" or "Off").
     - Method: `toggle_power()` to turn the device on or off.
   - `WiFiDevice`: Represents devices that can connect to WiFi.
     - Attribute: `connected` (Boolean, whether it’s connected to WiFi).
     - Method: `connect_wifi()` and `disconnect_wifi()`.
   - `SmartDevice`: A device that can be both power-operated and WiFi-enabled.
     - Inherits from both `PowerDevice` and `WiFiDevice`.

2. The `SmartDevice` class should:
   - Combine attributes from both parent classes.
   - Add its own attribute: `device_name`.
   - Include a method `device_info()` to print the device’s name, power status, and WiFi connection status.

---

#### **Example Input/Output**:

##### **Example 1**:
```python
# Create a SmartDevice
smart_bulb = SmartDevice("Smart Bulb")

# Turn the device on
smart_bulb.toggle_power()
# Connect it to WiFi
smart_bulb.connect_wifi()

# Display device information
smart_bulb.device_info()
```

Output:
```plaintext
Device: Smart Bulb
Power Status: On
WiFi Status: Connected
```

##### **Example 2**:
```python
# Create another SmartDevice
smart_thermostat = SmartDevice("Smart Thermostat")

# Display initial status
smart_thermostat.device_info()

# Turn on power but leave WiFi disconnected
smart_thermostat.toggle_power()

# Display updated status
smart_thermostat.device_info()
```

Output:
```plaintext
Device: Smart Thermostat
Power Status: On
WiFi Status: Not Connected
```

---

#### **Detailed Explanation**:

1. **PowerDevice Class**:
   - Manages the device's power status (`On` or `Off`).
   - Provides a method `toggle_power()` to switch the state.

2. **WiFiDevice Class**:
   - Manages WiFi connectivity using a boolean `connected`.
   - Provides methods to connect or disconnect from WiFi.

3. **SmartDevice Class**:
   - Inherits from both `PowerDevice` and `WiFiDevice`.
   - Combines functionality from both parents and adds its own attribute (`device_name`) and method (`device_info()`).

4. **Multiple Inheritance**:
   - Demonstrates how to combine functionality from two different base classes.
   - Shows how to initialize multiple parent classes using `super()` or explicit calls.


#### **Edge Cases to Test**:
1. A device is powered off but connected to WiFi—ensure this is reflected in the output.
2. A device is created but neither powered on nor connected to WiFi.
3. Test multiple devices with independent states to ensure proper attribute handling.

"""

class PowerDevice:
  def __init__(self):
    self.power_status = 'On'

  def toggle_power(self):
    self.power_status = 'On' if self.power_status == 'Off' else 'Off'

class WiFiDevice:
  def __init__(self):
    self.connected = False

  def connect_wifi(self):
    self.connected = True

  def disconnect_wifi(self):
    self.connected = False

class SmartDevice(PowerDevice, WiFiDevice):
  def __init__(self, device_name):
    PowerDevice.__init__(self)
    WiFiDevice.__init__(self)
    self.device_name = device_name

  def device_info(self):
    print(f"Device: {self.device_name}")
    print(f"Power Status: {self.power_status}")
    print(f"Wifi Status: {'Connected' if self.connected else 'Not Connected'}")


# Test cases
smart_bulb = SmartDevice("Smart Bulb")
smart_bulb.toggle_power()
smart_bulb.connect_wifi()
smart_bulb.device_info()

smart_thermostat = SmartDevice("Smart Thermostat")
smart_thermostat.device_info()
smart_thermostat.toggle_power()
smart_thermostat.device_info()

"""### **Challenge 6: Library Book Management System (With Type Hinting and Type Checking)**

#### **Objective**:
Build a program for managing a library's collection of books, ensuring that all functions and classes use **type hints** effectively. Use **mypy** to perform type checking and ensure type safety.

#### **Problem Statement**:
Create a library management system with the following requirements:
1. Represent each book in the library as a dictionary with the following keys:
   - `"title"`: A string representing the book's title.
   - `"author"`: A string representing the book's author.
   - `"year"`: An integer representing the publication year.

2. Implement the following features:
   - **Add a Book**: A function to add a new book to the library.
   - **Find Books by Author**: A function to search for all books by a specific author.
   - **List All Books**: A function to display all books in the library.

3. Enforce the use of type hints in all functions and data structures:
   - Use **list of dictionaries** to store books.
   - Ensure proper type annotations for arguments and return values.


#### **Requirements**:
1. Use type hints in all functions, classes, and variables.
2. Validate the code with **mypy** to ensure there are no type errors.
3. Add basic input validation to ensure data types are correct.

---

#### **Example Input/Output**:

#### **Example 1**:
```python
library = []

# Add books
add_book(library, "To Kill a Mockingbird", "Harper Lee", 1960)
add_book(library, "1984", "George Orwell", 1949)
add_book(library, "Animal Farm", "George Orwell", 1945)

# List all books
list_books(library)
# Output:
# 1. "To Kill a Mockingbird" by Harper Lee (1960)
# 2. "1984" by George Orwell (1949)
# 3. "Animal Farm" by George Orwell (1945)

# Find books by George Orwell
books_by_orwell = find_books_by_author(library, "George Orwell")
print(books_by_orwell)
# Output:
# [{"title": "1984", "author": "George Orwell", "year": 1949},
#  {"title": "Animal Farm", "author": "George Orwell", "year": 1945}]
```

---

#### **Instructions for Students**:
1. Save the code to a Python file (e.g., `library.py`).
2. Run the program normally to ensure functionality.
3. Install **mypy** if not already installed:
   ```bash
   pip install mypy
   ```
4. Use mypy to check for type errors:
   ```bash
   mypy library.py
   ```
5. If any type errors are detected, fix them and re-run the type check.


#### **Edge Cases to Test**:
1. Adding a book with missing or incorrect data types (e.g., non-integer year).
2. Searching for an author who has no books in the library.
3. Listing books when the library is empty.

"""

from typing import List, TypedDict

class Book(TypedDict):
  title: str
  author: str
  year: int

def add_book(library: List[Book], title: str, author: str, year: int) -> None:
  book: Book = {"title": title, "author": author, "year": year}
  library.append(book)

def find_books_by_author(library: List[Book], author: str) -> List[Book]:
  return [book for book in library if book["author"] == author]

def list_books(library: List[Book]) -> None:
  if not library:
    print("The library is empty.")
    return

  for index, book in enumerate(library, start=1):
    print(f"{index}. \"{book['title']}\" by {book['author']} ({book['year']})")

# Example Usage
if __name__ == "__main__":
    library: List[Book] = []
    add_book(library, "To Kill a Mockingbird", "Harper Lee", 1960)
    add_book(library, "1984", "George Orwell", 1949)
    add_book(library, "Animal Farm", "George Orwell", 1945)

    print("\nAll Books:")
    list_books(library)

    print("\nBooks by George Orwell:")
    books_by_orwell = find_books_by_author(library, "George Orwell")
    print(books_by_orwell)